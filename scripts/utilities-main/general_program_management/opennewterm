#!/usr/bin/env bash
# 
# Open a new terminal emulator with an initial command.
# 
# Usage:
#   opennewterm [initial command]
# 
# Returns:
#   The window ID of the new terminal emulator window.
# 
# Dependencies:
#   xterm (the terminal emulator used)
#   wmctrl (used to get the window ID of the new terminal emulator window)
# 

# ============================================
#   Utilitiy functions
# ============================================

getWindIdByPid() {
  while IFS= read line; do
    if [[ "${line}" =~ (0x)([0-9a-z]+)([ ][- ][0-9]+[ ])([0-9]*) ]]; then
      local winId="${BASH_REMATCH[1]}${BASH_REMATCH[2]}"
      local pid="${BASH_REMATCH[4]}"
      if [ "${pid}" -eq "${1}" ]; then
        echo "${winId}"
        break
      fi
    fi
  done < <(wmctrl -lp)
}

# ============================================
#   Launch terminal emulator
# ============================================

nohup xterm -sl 9000 -xrm "XTerm.vt100.allowTitleOps: ${allowTtlOps}" -title \
    "${title}" -geometry "${geometry}" -fa "${FONT_FACE}" -fs "${fontSize}" \
    ${colorProps} -e bash -c "$(printf '%s\nexec bash' "${*}")" &>/dev/null &
    # "$(printf '%s\nexec bash' "${*}")" here allows any command to be passed
    # in, including a bash Here document.

PID="$!"

sleep .08
WIND_ID="$(getWindIdByPid "${PID}")"

# Check stdout and stderr to see if they point to a terminal; if so, redirect
# to /dev/null to prevent unnecessary output to the terminal (note that the
# window ID is still obtainable in a subprocess).
if test -t 1; then
  exec 1>/dev/null
fi
if test -t 2; then
  exec 2>/dev/null
fi

# echo window ID so caller can obtain it
echo "${WIND_ID}"

