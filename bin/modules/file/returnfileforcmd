#!/usr/bin/env bash
# 
# Return a file for a command using one of two search methods:
#   1. Locate from a database (using a "locate" command; see Notes)
#   2. Recursively find from the current or specified directory
# 
# Options are provided to change the find occurrence and to find all occurrences
# for both methods.
# 
# Examples:
#   # locate a file from a database for gedit
#   alias geditloc='returnfileforcmd {gedit --new-window} --l'
# 
#   # recursively find a file from the current or specified directory for gedit
#   alias geditr='returnfileforcmd {gedit --new-window} --r'
# 
#   # same as previous except allow files only to be returned
#   alias geditr='returnfileforcmd {gedit --new-window} --r --f'
# 
#   # use the aliases on their own or with other options such as --a to return
#   # all occurrences
#   geditloc project-config.sh
#   geditr --a config.sh
# 
# Notes:
#   To use the locate method, there must exist a "locate" command in the user's
#   PATH environment variable that returns one or more file paths for a given
#   file name. The actual command name can be specified in the LOCATE_COMMAND
#   variable in CONFIGURATIONS. (Note: A locate utility package is provided in
#   the Packaged-utilities repository by Linux-shell-base).
# 
#   Options in this module will override matching ones for the command in
#   brackets. Therefore, they use double dashes to avoid collision as much as
#   possible.
# 
#   This module does not support file names with spaces.
# 

# ======= CONFIGURATIONS ==============

# Locate command.
readonly LOCATE_COMMAND='locate'

# Locate command option to locate directories only; can be empty.
readonly LOCATE_COMMAND_OPT_DIRS_ONLY='-d'

# Locate command option to change the find occurrence; must require a numerical
# argument; can be empty.
readonly LOCATE_COMMAND_OPT_FIND_OCCURRENCE='-o'

# ======= ! CONFIGURATIONS ==============

printHelpMessage() {
  echo -ne "\
returnfileforcmd - Return a file for a command.

Usage:
  returnfileforcmd {<command to execute>} [options] <partial file name>
        [directory]

  directory: directory to search in; applies only with the recursive search
             method; default is current.

Options:
  Note: This first set of options is used primarily with aliases.
  --l        use the locate search method
  --r        use the recursive search method
  --f        return files only
  --d        return directories only

  --<1-9>    change the find occurrence
  --a        use all occurrences instead of just the first
             (only applies to the recursive method)
  --e        test print the found file without executing the
             command
  --help     show this help message
"
}

# Note: The following could be done using "set", however, it removes all
# arguments containing "?".
for ((x=1; x<=$#; x++)); do
  if [[ "${@:x:1}" = *'}'* ]]; then
    execCmd="${@:1:x}"
    shift ${x}
  fi
done
if [ -z "${execCmd}" ]; then
  echo -e "returnfileforcmd: invalid arguments: \n   \"${@}\"\n" 1>&2
  printHelpMessage
  exit 1
fi

execCmd="${execCmd#{}"
execCmd="${execCmd%\}}"

OPTS="$(getopt -q -o '#' --long l,r,f,d,1,2,3,4,5,6,7,8,9,a,e,help -n \
    'returnfileforcmd' -- "${@}")"
eval set -- "${OPTS}"
while true; do
  case "${1}" in
    --l) SEARCH_METHOD='locate';;
    --r) SEARCH_METHOD='recursion';;
    --f) SEARCH_TYPE='f';;
    --d) SEARCH_TYPE='d';;
    --1|--2|--3|--4|--5|--6|--7|--8|--9) FIND_OCCURRENCE="${1#'--'}";;
    --a) ALL_OCCURRENCES=true;;
    --e) PRINT_ONLY=true;;
    --help) printHelpMessage; exit;;
    --) shift; break;;
    * ) break;;
  esac
  shift
done

case "${SEARCH_METHOD}" in
  'locate')
    if [ "$#" -eq 0 ]; then
      echo 'returnfileforcmd: no file specified' 1>&2
      exit 1
    fi
    if ! hash ${LOCATE_COMMAND} > /dev/null 2>&1; then
      echo "returnfileforcmd: command \"${LOCATE_COMMAND}\" does not"\
          "exist" 1>&2
      exit 1
    fi

    if [[ "${SEARCH_TYPE}" = 'd' && -n "${LOCATE_COMMAND_OPT_DIRS_ONLY}" ]]
    then
      lctOpts="${LOCATE_COMMAND_OPT_DIRS_ONLY}"
    fi

    if [[ -n "${FIND_OCCURRENCE}" && -n \
        "${LOCATE_COMMAND_OPT_FIND_OCCURRENCE}" ]]; then
      lctOpts+=" ${LOCATE_COMMAND_OPT_FIND_OCCURRENCE} ${FIND_OCCURRENCE}"
    fi

    output="$(${LOCATE_COMMAND} ${lctOpts} "${@}")"

    if [ -z "${output}" ]; then
      echo 'returnfileforcmd: no files or directories found' 1>&2
    else
      output="$(echo "${output}" | sed 's/ /\\n/g')"

      if [ "${PRINT_ONLY}" = 'true' ]; then
        echo "${output}"
      else
        ${execCmd} "${output}"
      fi
    fi
    ;;

  'recursion')
    if [ "$#" -eq 0 ]; then
      echo 'returnfileforcmd: no file specified' 1>&2
      exit 1
    elif [ "$#" -ge 2 ]; then
      dir="${2}"
    else
      dir='.'
    fi

    if [ -n "${SEARCH_TYPE}" ]; then
      optType="-type ${SEARCH_TYPE}"
    fi

    output="$(find "${dir}" ${optType} -name "*${1}*" 2>/dev/null)"

    if [ -z "${output}" ]; then
      echo 'returnfileforcmd: no files or directories found' 1>&2
    else
      if [ "${ALL_OCCURRENCES}" != 'true' ]; then
        if [ -n "${FIND_OCCURRENCE}" ]; then
          if [ "${FIND_OCCURRENCE}" -gt "$(echo "${output}" | wc -l)" ]; then
            FIND_OCCURRENCE="${lastOccur}"
          fi

          output="$(echo "${output}" | sed "${FIND_OCCURRENCE}q;d")"
        else
          output="$(echo "${output}" | sed "1q;d")"
        fi
      fi

      if [ "${PRINT_ONLY}" = 'true' ]; then
        echo "${output}"
      else
        ${execCmd} "${output}"
      fi
    fi
    ;;

  *)
    for execCmdArg in ${@}; do
      if [[ "${execCmdArg::2}" =~ '-' ]]; then
        execCmdOpts+="${execCmdArg} "
        shift
      fi
    done

    ${execCmd} ${execCmdOpts} "${@}"
    ;;
esac

